%\section{Primitive input generator}\label{sec:pig}
\section{Input generator}\label{sec:pig}
%The process of the generator works hand by hand with the \emph{Test Generator}~\ref{sec:tg}, and it does multiple works.
%The goal of this chapter is to define all the primitives types WRGen can generate and how values already instantiated could be reused during their lifecycle.\\
The goal of this chapter is to explain how the primitive input types are generated by WRGen.
%This work is based on the Java language, so its well-known primitives are maintained.

Java reflection APIs only offer the possibility to instantiate objects at runtime. Therefore, Java primitive types have to be instantiated using their object representations (\emph{Integer} for \emph{int}, \emph{Character} for \emph{char}\dots). The type \emph{String} is already an object in the Java language, there is no primitive counterpart.

When the test generator requires a new variable of a primitive type, the primitive input generator creates an object of that type using the default constructor, assigning a fixed value (\hl{what is the fixed value?}). 

Then, it checks if a value of that type was previously generated. If yes, with an equal probability (\hl{which is?}) the program generates a new value or picks a previously generated one (\hl{if no, what happens?}). There is a third option for object types that is the \emph{null} value, but it is chosen with a smaller probability (\hl{which is and why is it smaller?}).

When a previously generated value is chosen, the input generator links the new variable with the one the previously generated value of the same type was assigned to. Otherwise, a random value is generated using the \textit{Random} Java class. For some primitive types the Random class can generate values directly, as in the case of \textit{int}, \textit{float}, \textit{long}, \textit{double}, \textit{boolean}. \autoref{st:genDef} shows how these primitive types are handled by the input generator. 

%\lstset{language=XML} 
\begin{lstlisting}[caption={Random default generator},label={lst:genDef}]% Start your code-block

case "java.lang.Integer":
	obj.setValue(random.nextInt());
case "java.lang.Float":
	obj.setValue(random.nextFloat());
case "java.lang.Long":
	obj.setValue(random.nextLong());
case "java.lang.Double":
	obj.setValue(random.nextDouble());
case "java.lang.Boolean":
	obj.setValue((random.nextBoolean());
\end{lstlisting}

However, in case of \textit{short}, the input generator generates a random \textit{int} value that is then transformed in a \textit{short} value using the Java type definition for \textit{short}, as shown in \autoref{lst:genShort}.

\begin{lstlisting}[caption={Random short generator},label={lst:genShort}]% Start your code-block
	
case "java.lang.Short":
	obj.setValue(random.nextInt(65536) - 32768);
\end{lstlisting}

Char and String require more operations, thus the input generator uses an extra function (see \autoref{lst:genString&Char}).

\begin{lstlisting}[caption={Random String/char generator},label={lst:genString&Char}]% Start your code-block

public static String generateRandomChars(String candidateChars, int length, Random random) {
	StringBuilder sb = new StringBuilder();
	for (int i = 0; i < length; i++) {
		sb.append(candidateChars.charAt(random.nextInt(candidateChars.length())));
	}
	return sb.toString();
}
\end{lstlisting}

The difference between String and char is the length, which is 1 for char, and it is random generated for String. The variable \emph{candidateChars} in \autoref{lst:genString&Char} is a string of desired characters. For example, it could be the concatenation of upper/lower case letters and numbers if those are the desired characters a user of WRGen wants in his/her random string values (\hl{is it a parameter of your tool?}).

In the Java language, there are also other types of objects and one of them is the \textit{Enumerator}. The input generator considers \textit{Enum} as a primitive type and when one is required, it randomly chooses a value from those specified by the particular Enum type. \hl{With Enums, the equal operation work differently and so, the links for the usage of old values are not necessary}. 

If the input parameter to be generated is not of a primitive type, a recursive approach is adopted (see \autoref{psc:instantiator}). The non primitive type class is analyzed, collecting all its constructors. Then one is randomly picked and, if the constructor requires input parameters, the random generation process is called recursively on each parameter (line~14). If the constructor does not require any input parameter, Java reflection can instantiate it directly. If the same constructor, with at least one input parameter, was previously instantiated with a probability of \hl{XX} is picked. As in the case of primitive values the reference to the previous variable assignment is saved accordingly.

\begin{algorithm}
	\caption{Instantiator}\label{psc:instantiator}
	\begin{algorithmic}[1]
		\Procedure{instantiate}{params}
		\ForAll{$params$}
			\State $param \gets \textit{params.next}$
			\If {$\textit{isPrimitive(param)}$} 
				\State $param \gets \Call{instantiateWithReflectionOrOldValue}{}$
			\ElsIf {$\textit{isEnum(param)}$} 
				\State $param \gets \Call{pickRandomEnumConstant}{param}$
			\ElsIf {$\textit{isInterface(param)}$} 
				\State $param \gets \Call{instantiate}{\textit{param.getSubclass.getParameter()}}$
			\Else 
				\If {$\textit{directlyInstantiable(param)}$} 
					\State $param \gets \Call{instantiateWithReflectionOrOldValue}{}$
				\Else 
					\State $requireInstances \gets \Call{instantiate}{\textit{param.getParameter()}}$
					\State $param \gets \Call{instantiateWithReflectionOrOldValue}{\textit{requireInstances}}$
				\EndIf
			\EndIf	
		\EndFor
		\Return $params$ \Comment{$All~the~instantiated~objects$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Let us suppose that there is a class \textit{A} that has to be instantiated. It is neither a  primitive type nor an enum, so one of its constructor is picked randomly (line~10 in \autoref{psc:instantiator}). Suppose that the one picked requires two parameters, like an int type and another class \textit{B}. Therefore, the generator is called recursively on the int variable and on the class \textit{B} (line~14). Regarding the int type, the program could generate a new value or pick an old one if it was previously generated (line~5) \hl{remind the probability value to the reader}. Suppose that the class \textit{B} has only the default empty constructor, thus Java reflection can instantiate it directly (line~12). Once all the parameters of class \textit{A} are created class \textit{A} can be instantiated with those values (line~15). With this recursive procedure the input generator is able to instantiate parameters of any types.

%As an example of the environment requirement, in case of a class X is required to be instantiated and its source is not in the class-path, the instantiation fail and the creation of tests \emph{is} compromised.

%Until now, the program has take care only of directly instantiable objects, avoiding Interfaces.\\
%The management of those classes need an extra work, that consist in finding one of its sub-classes that can be instantiate in its place.\\

Regarding interfaces, that cannot be instantiated directly, the input generator has to search in the classpath for all those classes that implement the required interface. \autoref{lst:interfaceMngmnt} shows how the interfaces are managed by the input generator.
%The operation is done filtering all the classes related to the interface's project and searching for \emph{Beans} that extend the class.\\

\begin{lstlisting}[caption={how to find a sub-class of an interface},label={lst:interfaceMngmnt}]% Start your code-block

ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
provider.addIncludeFilter(new AssignableTypeFilter(target));
Set<BeanDefinition> components = provider.findCandidateComponents("./");
for (BeanDefinition component : components){
	Class cls = Class.forName(component.getBeanClassName());
	// use class cls found
}
\end{lstlisting}
The \textit{ClassPathScanningCandidateComponentProvider} and \textit{BeanDefinition} are taken from the Spring Framework~\cite{springFramework}.
\hl{How is the choice performed when there is more than one class that implements the required interface? Randomly? Once a class that implements the required interface is found what happens?}

%Interfaces are commonly used to make reference of it that refers to the Object of its implementing class, and this is why the program manage them.