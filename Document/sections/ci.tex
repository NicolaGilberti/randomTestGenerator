\section{Class Instrumentor}\label{sec:ClassInstr}
This section explain the classes inside the package \emph{spoon}.
The main dependency for this package is Spoon, explained in Section~\ref{sec:spoon}.\\
The \emph{ClassModifier} class prepare the Spoon environment.
In detail, it generate all the variable that are necessary to create/modify elements in a java class.\\
The program need to insert extra code inside an existing class, so a \emph{factory} object must be instantiated.
In addition, Spoon requires a data model of the class under analysis, as seen in~\ref{subsec:howSpoon}.
This is generated by a Spoon Object that return, given the source-path, the AST where the root is the given path.
\begin{lstlisting}[caption={The function to create the AST from the ClassModifier class},label={lst:ASTmodel}]% Start your code-block

protected void buildModel(File sourcePath) throws IOException {
	builder = new JDTBasedSpoonCompiler(factory);		
	try {
		builder.addInputSource(sourcePath);
		builder.build();
	}catch (Exception e) {
		throw new RuntimeException(e);
	}		
}
\end{lstlisting}
Now the Spoon requirements are setted and the \emph{SpoonMod} class, can be istantiated to effectively instrument the class under test.\\
The instrumentation depends on the scope of the analysis required.
Program can generate extra code to pursue a line or branch coverage.\\
In each case, target is reached using an ArrayList~\cite{ArrayList} that collect the identifier of the lines/branches when the execution pass through them.\\
To work, the ArrayList has to be defined, instantiated and then it can be used to collect the required data.\\
The algorithm work with random choices, so the instantiation has to be done carefully.\\
To be sure that there will be no runtime exceptions, the program modify all the constructor of the class.
In case the target doesn't implement a constructor, the empty one is still available and reachable from the code below~\ref{lst:modConstructor}.\\
After that, we need to place all the add operation on the arraylist where required.
In case of branch coverage, the instrumentor search for \emph{If} structures, and add a snippet~\ref{lst:addSnippet} in the first line of each block of execution, \emph{then} and \emph{else} blocks.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Snippet creation},label={lst:addSnippet}]% Start your code-block
	
factory.Code().createCodeSnippetStatement("checker.add("+ counter++ +")");
\end{lstlisting}
\end{minipage}\\
As we can see, a counter is used to identify uniquely a branch.\\
In case of line coverage the snippet is the same, while the placing task no.
In fact extra data are collected from~\ref{sec:prop} that provide the lines to cover.\\
The instrumentor does a bottom-up scan searching for the lines, and when there is a match it append the snippet shifting one line down the rest of the code.\\

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={The function to add the ArrayList instantiation snippet},label={lst:modConstructor}]% Start your code-block

private void modConstructors(CtClass cc) {
	List<?> tmp;
	CtConstructor<?> constructor;
	Set<?> constructors = cc.getConstructors();
	Iterator<?> itc = constructors.iterator();
	while(itc.hasNext()) {
		constructor = (CtConstructor<?>) itc.next();
		CtBlock<?> ctb = constructor.getBody();
		tmp = ctb.getStatements();
		List<CtStatement> newStatements = new ArrayList<CtStatement>();
		CtCodeSnippetStatement newStatement = factory.Code().createCodeSnippetStatement("checker = new ArrayList()");
		newStatements.add(newStatement);
		for(int j = 0; j < tmp.size(); j++){
			newStatements.add((CtStatement) tmp.get(j));
		}
		ctb.setStatements(newStatements);
	}
}
\end{lstlisting}
\end{minipage}
The~\href{\projRootLink/support/spoon/SpoonMod.java}{SpoonMod class} generate extra methods in the class under test for the run-time management tasks, like getting data from the ArrayList or resetting it for the next execution.
The last operation that this class provide is an analysis of the class to understand all the default fields, in order to have those values as options when instantiating variables for the class methods.