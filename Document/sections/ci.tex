\section{Class Instrumentor}\label{sec:ClassInstr}
This section explains how the input class is instrumented. The main dependency for this package is Spoon, explained in \autoref{sec:spoon}.

The \emph{ClassModifier} class prepares the Spoon environment.
Specifically, it generates all the variables that are necessary to create/modify elements in the Java input class. The program needs to insert extra code in the input class, therefore a \emph{factory} object must be instantiated. In addition, Spoon requires a data model of the class under analysis, as seen in \autoref{subsec:howSpoon}. This is generated by a Spoon object that returns, given the source-path of the input class under analysis, the AST of the input class.

\begin{lstlisting}[caption={The function to create the AST from the ClassModifier class},label={lst:ASTmodel}]% Start your code-block

protected void buildModel(File sourcePath) throws IOException {
	builder = new JDTBasedSpoonCompiler(factory);		
	try {
		builder.addInputSource(sourcePath);
		builder.build();
	}catch (Exception e) {
		throw new RuntimeException(e);
	}		
}
\end{lstlisting}

Once the AST is created than the class under test can be instrumented. WRGen can instrument the class under test to measure both branch and line coverage. In both cases, when the target (line or branch) is reached during the execution of a test, WRGen uses a list that collects the identifier of the line/branch covered.

%The algorithm work with random choices, so the instantiation has to be done carefully.\\
%To be sure that there will be no runtime exceptions, the program modify all the constructor of the class.
%In case the target doesn't implement a constructor, the empty one is still available and reachable from the code below~\ref{lst:modConstructor}.\\
%After that, we need to place all the add operation on the arraylist where required.

In case of branch coverage, the instrumentor searches for \emph{If} structures, and adds a statement (\autoref{lst:addSnippet}) in the first line of each \emph{then} and \emph{else} block. A counter is used to uniquely identify a branch.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Snippet creation},label={lst:addSnippet}]% Start your code-block
	
factory.Code().createCodeSnippetStatement("checker.add("+ counter++ +")");
\end{lstlisting}
\end{minipage}

In case of line coverage the statement added is the same, while the analysis of the class under test is different. In fact the instrumentor takes as input the lines of the class under test to cover and performs a bottom-up scan searching for the lines. When there is a match it appends the instrumentation snippet shifting one line down the rest of the code (????).

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={The function to add the ArrayList instantiation snippet},label={lst:modConstructor}]% Start your code-block

private void modConstructors(CtClass cc) {
	List<?> tmp;
	CtConstructor<?> constructor;
	Set<?> constructors = cc.getConstructors();
	Iterator<?> itc = constructors.iterator();
	while(itc.hasNext()) {
		constructor = (CtConstructor<?>) itc.next();
		CtBlock<?> ctb = constructor.getBody();
		tmp = ctb.getStatements();
		List<CtStatement> newStatements = new ArrayList<CtStatement>();
		CtCodeSnippetStatement newStatement = factory.Code().createCodeSnippetStatement("checker = new ArrayList()");
		newStatements.add(newStatement);
		for(int j = 0; j < tmp.size(); j++){
			newStatements.add((CtStatement) tmp.get(j));
		}
		ctb.setStatements(newStatements);
	}
}
\end{lstlisting}
\end{minipage}

The instrumentor (see \autoref{lst:modConstructor})
%~\href{\projRootLink/support/spoon/SpoonMod.java}{SpoonMod class}
creates extra methods in the class under test that are needed during test case execution, like getting data from the list of targets and resetting it after  every test execution.

%The last operation that the instrumentor performs is an analysis of the class under test to understand all the default fields, in order to have those values as options when instantiating variables for the class methods. 
Finally the instrumentor loops through all the methods of the class under test to store the parameter types each method takes as input. This information is useful during test generation, to generate input values of the right type.